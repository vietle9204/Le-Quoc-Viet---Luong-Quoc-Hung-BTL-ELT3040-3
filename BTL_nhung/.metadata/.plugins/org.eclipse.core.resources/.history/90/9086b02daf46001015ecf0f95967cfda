#include "stm32f4xx_hal.h"
#include "stdio.h"
#include "math.h"
#include "string.h"
#include "usart_esp32.h"
#include "ssd1306.h"

#define low_gar_default_value 15
#define high_gar_default_value  150
#define warning_gar_default_value 300

#define system_on 1
#define system_off 0

int sys_state = system_on;
//int sys_flag = 1;

int warning_state = 0;
int gar_flag = 0;

int ppm_value = 0;
uint16_t adc_value = 0;



void SystemClock_Config(void);
static void MX_GPIO_Init(void);
void Error_Handler(void);



void init_timer1_led_RGB(void);
void RGB_update(int R, int G, int B, int FREQ);

void OnOffSwitch_Init(void);
void ResetSwitch_Init(void);

void init_ADC_MQ2(void);

void init_relay(void);
void init_buzzer(void);

void OnOffSwitch_Init(void) {
	// Enable GPIOA clock
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;

	// PA1 input mode (default), pull-up
	GPIOA->MODER &= ~(3U << (1 * 2));           // Input mode
	GPIOA->PUPDR &= ~(3U << (1 * 2));           // Clear
	GPIOA->PUPDR |= (1U << (1 * 2));           // Pull-up

	// Enable SYSCFG clock
	RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;

	// Connect EXTI1 line to PA1
	SYSCFG->EXTICR[0] &= ~(0xF << (1 * 4));     // EXTI1 -> PA1

	// Unmask EXTI1
	EXTI->IMR |= (1U << 1);

	// Falling edge trigger
	EXTI->FTSR |= (1U << 1);
	EXTI->RTSR &= ~(1U << 1);

	// Enable EXTI1 interrupt in NVIC
	NVIC_EnableIRQ(EXTI1_IRQn);
}

void ResetSwitch_Init(void) {
	// Enable GPIOA clock
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;

	// PA2 input mode, pull-up
	GPIOA->MODER &= ~(3U << (2 * 2));           // Input mode
	GPIOA->PUPDR &= ~(3U << (2 * 2));           // Clear
	GPIOA->PUPDR |= (1U << (2 * 2));           // Pull-up

	// Enable SYSCFG clock
	RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;

	// Connect EXTI2 line to PA2
	SYSCFG->EXTICR[0] &= ~(0xF << (2 * 4));     // EXTI2 -> PA2

	// Unmask EXTI2
	EXTI->IMR |= (1U << 2);

	// Falling edge trigger
	EXTI->FTSR |= (1U << 2);
	EXTI->RTSR &= ~(1U << 2);

	// Enable EXTI2 interrupt in NVIC
	NVIC_EnableIRQ(EXTI2_IRQn);
}

void system_on_off(int state) {
	if (state) {
		ADC1->CR2 |= ADC_CR2_ADON;

		TIM1->CR1 |= TIM_CR1_CEN;

		ssd1306_goto(0, 0);
		ssd1306_put_string("sys_status: 1 - on  ");
	} else {
		//tắt adc
		ADC1->CR2 &= ~ADC_CR2_ADON;  // tắt adc

		//tắt rgb
		RGB_update(0, 0, 0, 0);
		TIM1->CR1 &= ~TIM_CR1_CEN;

		//tắt buzzer và relay
		GPIOB->ODR &= ~(1 << 12);
		GPIOA->ODR |= (1 << 12);

		ssd1306_goto(0, 0);
		ssd1306_put_string("sys_status: 0 - off ");

	}

}

void EXTI1_IRQHandler(void) {
	if (EXTI->PR & (1U << 1)) {

		// set cờ sys_flag
		sys_state ^= 1;

		system_on_off(sys_state);

		EXTI->PR |= (1U << 1); // Clear interrupt pending
	}
}



void EXTI2_IRQHandler(void) {
	if (EXTI->PR & (1U << 2)) {
		// Xử lý Reset Switch (PA2)
		system_on_off(system_off);
		ssd1306_goto(0, 0);
		ssd1306_put_string("sys_status: reset ");

		while(!(GPIOA->IDR >> 2 & 0x1));    // chờ tới khi nút nhấn được nhả
		system_on_off(system_on);


		EXTI->PR |= (1U << 2); // Clear interrupt pending
	}
}

void init_ADC_MQ2(void) {
	// Cấu hình GPIOA chế độ analog để đọc ADC
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;  	// Bật clock GPIOA
	GPIOA->MODER &= ~(3 << (0 * 2));  		// Xóa cấu hình cũ của PA0
	GPIOA->MODER |= (3 << (0 * 2)); // Chọn chế độ analog cho PA0 (MODER00 = 11)

	// Cấu hình bộ ADC
	RCC->APB2ENR |= RCC_APB2ENR_ADC1EN;     // Bật clock cho ADC1

	ADC1->CR1 &= ~ADC_CR1_RES_Msk;        	// Xóa cấu hình độ phân giải cũ
	ADC1->CR1 |= 2 << ADC_CR1_RES_Pos; // Chọn độ phân giải 8 bit (10 = 8-bit resolution)
	ADC1->CR1 |= ADC_CR1_EOCIE;	// Bật ngắt khi ADC chuyển đổi hoàn tất (EOC)

	ADC1->SMPR2 |= (3 << (0 * 3)); // Cấu hình thời gian lấy mẫu cho kênh 0: 56 cycles

	ADC1->SQR3 &= ~(0xF << 0);              // Chọn kênh ADC = kênh 0 (PA0)

	ADC1->CR2 |= ADC_CR2_ADON;            	// Bật ADC1 (Enable ADC)

	NVIC_EnableIRQ(ADC_IRQn); 				// Bật ngắt ADC trong NVIC
//	NVIC_SetPriority(ADC_IRQn, 3); 			// Ưu tiên mức 1 cho ngắt ADC
}

int ppm_caculator(uint16_t data) {
	// Tính điện áp từ giá trị ADC đọc được (độ phân giải 8-bit → 256 mức)
//	double voltage = 5 * data / 256.0;
	// Tính điện trở Rs theo điện áp
	double Rs = 1000.0 * ((256.0 - data) / data);
	// Tỷ số Rs/Ro (Ro = 1000 ohm, giả sử)
	double divRsRo = Rs / 2000.0;
	// Tính log10(ppm) từ đường cong đặc trưng
	float log_ppm = -0.47 * log10f(divRsRo) + 1.45;
	// Tính ppm bằng cách mũ hóa cơ số 10
	return (int) powf(10.0, log_ppm);
}

void ADC_IRQHandler(void) {
	if (ADC1->SR & (1 << 1)) 	// Kiểm tra cờ EOC (End Of Conversion)
			{
		adc_value = ADC1->DR;   			// Đọc giá trị ADC
		ppm_value = ppm_caculator(adc_value); 	// Tính toán ppm từ giá trị ADC

		if (ppm_value < low_gar_default_value) {
			//cập nhật trạng thái
			if (warning_state == 0)
				return;
			else {
				warning_state = 0;
				gar_flag = 1;
			}
		}

		else if (ppm_value >= low_gar_default_value
				&& ppm_value < high_gar_default_value) {
			if (warning_state == 1)
				return;
			else {
				warning_state = 1;
				gar_flag = 1;
			}
		}

		else if (ppm_value >= high_gar_default_value
				&& ppm_value < warning_gar_default_value) {
			if (warning_state == 2)
				return;
			else {
				warning_state = 2;
				gar_flag = 1;
			}
		}

		else if (ppm_value >= warning_gar_default_value) {
			if (warning_state == 3)
				return;
			else {
				warning_state = 3;
				gar_flag = 1;
			}
		}

		ADC1->SR &= ~(1 << 1);  			// Xóa cờ EOC
	}

}

void init_timer1_led_RGB(void) {
	// 1. Bật clock GPIOA và TIM1
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
	RCC->APB2ENR |= RCC_APB2ENR_TIM1EN;

	// 2. Cấu hình các chân PA8, PA9, PA10 làm Alternate Function (AF1 tương ứng với TIM1)
	GPIOA->MODER &= ~((3 << (8 * 2)) | (3 << (9 * 2)) | (3 << (10 * 2))); // Xóa cấu hình cũ
	GPIOA->MODER |= (2 << (8 * 2)) | (2 << (9 * 2)) | (2 << (10 * 2)); // Đặt chế độ AF

	GPIOA->AFR[1] &= ~((0xF << ((8 - 8) * 4)) | (0xF << ((9 - 8) * 4))
			| (0xF << ((10 - 8) * 4)));
	GPIOA->AFR[1] |= (1 << ((8 - 8) * 4)) | (1 << ((9 - 8) * 4))
			| (1 << ((10 - 8) * 4));  // AF1

	// 3. Cấu hình Timer1
	TIM1->PSC = 79999;        // Prescaler: giảm từ 80 MHz xuống 1 kHz
	TIM1->ARR = 999;          // Auto-reload: 1s chu kỳ (1 tick = 1ms)

	// 4. Đặt giá trị so sánh ban đầu cho 3 kênh PWM (CCR)
	TIM1->CCR1 = 0;
	TIM1->CCR2 = 0;
	TIM1->CCR3 = 0;

	// 5. Cấu hình chế độ PWM cho các kênh (OC1, OC2, OC3)
	TIM1->CCMR1 &= ~(TIM_CCMR1_OC1M | TIM_CCMR1_OC2M);  // Xóa mode cũ
	TIM1->CCMR2 &= ~(TIM_CCMR2_OC3M);                   // Xóa mode cũ

	TIM1->CCMR1 |= (0b111 << TIM_CCMR1_OC1M_Pos);  // PWM mode 2 cho OC1
	TIM1->CCMR1 |= (0b111 << TIM_CCMR1_OC2M_Pos);  // PWM mode 2 cho OC2
	TIM1->CCMR2 |= (0b111 << TIM_CCMR2_OC3M_Pos);  // PWM mode 2 cho OC3

	TIM1->CCER |= TIM_CCER_CC1E | TIM_CCER_CC2E | TIM_CCER_CC3E; // Cho phép xuất tín hiệu trên CH1, CH2, CH3

	// 6. Cho phép output (Main Output Enable)
	TIM1->BDTR |= TIM_BDTR_MOE;

	// 7. Bắt đầu Timer
	TIM1->CR1 |= TIM_CR1_CEN;
}

void RGB_update(int R, int G, int B, int FREQ) {
	TIM1->CR1 &= ~TIM_CR1_CEN;  // Dừng Timer để cập nhật

	if (FREQ == 0)  // Nếu không nhấp nháy
			{
		TIM1->ARR = 999;  // Chu kỳ 1 giây
		// Cập nhật duty cycle 100% hoặc 0% tùy màu
		TIM1->CCR1 = (R == 0) ? 0 : 999;
		TIM1->CCR2 = (G == 0) ? 0 : 999;
		TIM1->CCR3 = (B == 0) ? 0 : 999;
	} else  // Nếu có nhấp nháy
	{
		int arr_val = (1000 / FREQ) - 1; // Tính chu kỳ mới theo tần số mong muốn
		int duty = arr_val / 2;				// Duty cycle 50%

		TIM1->ARR = arr_val;				// Cập nhật chu kỳ mới
		TIM1->CCR1 = (R == 0) ? 0 : duty;
		TIM1->CCR2 = (G == 0) ? 0 : duty;
		TIM1->CCR3 = (B == 0) ? 0 : duty;
	}

	TIM1->EGR |= TIM_EGR_UG;  				// Tạo sự kiện cập nhật
	TIM1->CR1 |= TIM_CR1_CEN; 				// Khởi động lại Timer
}

void init_relay(void) {
	// 1. Bật clock cho port B
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOBEN;
	// 2. Cấu hình PB12 là output (MODER = 01)
	GPIOB->MODER &= ~(3 << (12 * 2));   // Clear 2 bit MODER12
	GPIOB->MODER |= (1 << (12 * 2));   // Set bit 12 thành 01 (output)
	// 3. Output type: push-pull (OTYPER = 0)
	GPIOB->OTYPER &= ~(1 << 12);        // Push-pull
	// 5. No pull-up, no pull-down (PUPDR = 00)
	GPIOB->PUPDR &= ~(3 << (12 * 2));
	// 6. Đặt mức logic ban đầu (LOW): relay off
	GPIOB->ODR &= ~(1 << 12);
}

void init_buzzer(void) {
	// 1. Bật clock cho port A
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
	// 2. Cấu hình PA12 là output (MODER = 01)
	GPIOA->MODER &= ~(3 << (12 * 2));   // Clear 2 bit MODER12
	GPIOA->MODER |= (1 << (12 * 2));   // Set bit 12 thành 01 (output)
	// 3. Output type: push-pull (OTYPER = 0)
	GPIOA->OTYPER &= ~(1 << 12);        // Push-pull
	// 5. No pull-up, no pull-down (PUPDR = 00)
	GPIOA->PUPDR &= ~(3 << (12 * 2));
	// 6. Đặt mức logic ban đầu (HIGH): relay off
	GPIOA->ODR &= 1 << 12;
}

int main(void) {
	HAL_Init();

	SystemClock_Config();
	MX_GPIO_Init();

	//	init_usart6();

	char str[12];  // bộ nhớ đủ lớn để chứa số nguyên và '\0'
/**
	ssd1306_init();
	ssd1306_clear();

	ssd1306_goto(0, 0);
	ssd1306_put_string("sys_status: 0 - off ");

	ssd1306_goto(0, 3);
	ssd1306_put_string("gar_state: 0 - non");

	ssd1306_goto(0, 5);
	ssd1306_put_string("ppm: 0");

	ssd1306_goto(0, 7);
	ssd1306_put_string("adc: 0");

	init_ADC_MQ2();
	init_timer1_led_RGB();
*/
	init_relay();
	init_buzzer();

	OnOffSwitch_Init();
	ResetSwitch_Init();
	RGB_update(0, 0, 1, 0);

	while (1) {

		if (sys_state) {

			if (gar_flag) {
				if (warning_state == 0) {
					RGB_update(0, 0, 1, 0);

					GPIOB->ODR &= ~(1 << 12);
					GPIOA->ODR |= (1 << 12);

					ssd1306_goto(66, 3);
					ssd1306_put_string("0 - non ");

				} else if (warning_state == 1) {
					RGB_update(1, 1, 0, 0);
					GPIOB->ODR &= ~(1 << 12);
					GPIOA->ODR |= (1 << 12);

					ssd1306_goto(66, 3);
					ssd1306_put_string("1 - low ");

				} else if (warning_state == 2) {

					RGB_update(1, 0, 0, 1);

					GPIOB->ODR |= 1 << 12;
					GPIOA->ODR |= 1 << 12;

					ssd1306_goto(66, 3);
					ssd1306_put_string("2 - high");

				} else if (warning_state == 3) {
					RGB_update(1, 0, 0, 5);

					GPIOB->ODR |= 1 << 12;
					GPIOA->ODR &= ~(1 << 12);

					ssd1306_goto(66, 3);
					ssd1306_put_string("3 - warnning");

				}

				gar_flag = 0;

			}
/**
			sprintf(str, "%d", ppm_value);  // chuyển số nguyên sang chuỗi
			ssd1306_goto(5, 5);
			ssd1306_put_string(str);

			sprintf(str, "%d", adc_value);
			ssd1306_goto(5, 7);
			ssd1306_put_string(str);

*/
			ADC1->CR2 |= ADC_CR2_SWSTART;         // Bắt đầu chuyển đổi
			for (int i = 0; i < 2000000; i++);
		}

	} /* USER CODE END 3 */
}

/**
 * @brief System Clock Configuration
 * @retval None
 */
void SystemClock_Config(void) {
	RCC_OscInitTypeDef RCC_OscInitStruct = { 0 };
	RCC_ClkInitTypeDef RCC_ClkInitStruct = { 0 };

	/** Configure the main internal regulator output voltage
	 */
	__HAL_RCC_PWR_CLK_ENABLE();
	__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);

	/** Initializes the RCC Oscillators according to the specified parameters
	 * in the RCC_OscInitTypeDef structure.
	 */
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
	RCC_OscInitStruct.HSEState = RCC_HSE_ON;
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
	RCC_OscInitStruct.PLL.PLLM = 15;
	RCC_OscInitStruct.PLL.PLLN = 96;
	RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
	RCC_OscInitStruct.PLL.PLLQ = 4;
	if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) {
		Error_Handler();
	}

	/** Initializes the CPU, AHB and APB buses clocks
	 */
	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK
			| RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

	if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK) {
		Error_Handler();
	}
}

/**
 * @brief GPIO Initialization Function
 * @param None
 * @retval None
 */
static void MX_GPIO_Init(void) {
	/* USER CODE BEGIN MX_GPIO_Init_1 */
	/* USER CODE END MX_GPIO_Init_1 */

	/* GPIO Ports Clock Enable */
	__HAL_RCC_GPIOH_CLK_ENABLE();
	__HAL_RCC_GPIOA_CLK_ENABLE();

	/* USER CODE BEGIN MX_GPIO_Init_2 */
	/* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

/**
 * @brief  This function is executed in case of error occurrence.
 * @retval None
 */
void Error_Handler(void) {
	/* USER CODE BEGIN Error_Handler_Debug */
	/* User can add his own implementation to report the HAL error return state */
	__disable_irq();
	while (1) {
	}
	/* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
